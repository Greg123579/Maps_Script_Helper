{
  "log_id": "b760db25-c350-4465-a01b-45c197cd696a",
  "session_id": "b760db25-c350-4465-a01b-45c197cd696a",
  "timestamp": "2025-12-21T11:58:33.703527",
  "status": "failed",
  "code": "# Last Code Update - 11:58:27\r\nimport os\r\nimport MapsBridge\r\nimport cv2\r\nimport numpy as np\r\nfrom skimage import filters, measure, morphology\r\nfrom PIL import Image # Used for converting OpenCV images to PIL if needed for some MapsBridge outputs, or for general image handling.\r\n\r\ndef process_image(image_path, tile_info=None, source_tile_set=None):\r\n    \"\"\"\r\n    Processes a single image to detect and count particles.\r\n\r\n    Args:\r\n        image_path (str): Path to the input image.\r\n        tile_info (MapsBridge.TileInfo, optional): Information about the tile being processed.\r\n                                                  Used for logging and output for Tile Sets.\r\n        source_tile_set (MapsBridge.SourceTileSet, optional): The source tile set object.\r\n                                                             Used for logging and output for Tile Sets.\r\n\r\n    Returns:\r\n        tuple: A tuple containing:\r\n            - str: Path to the output image with particles counted and displayed.\r\n            - int: The number of particles detected.\r\n    \"\"\"\r\n    try:\r\n        MapsBridge.LogInfo(f\"Reading image from: {image_path}\")\r\n        img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE) # Read as grayscale for particle detection\r\n\r\n        if img is None:\r\n            MapsBridge.LogError(f\"Could not read image: {image_path}\")\r\n            return None, 0\r\n\r\n        # Apply Gaussian blur for noise reduction\r\n        blurred_img = cv2.GaussianBlur(img, (5, 5), 0)\r\n\r\n        # Apply Otsu's thresholding to create a binary image\r\n        # The threshold value is automatically determined by Otsu's method\r\n        thresh_value, binary_img = filters.threshold_otsu(blurred_img)\r\n        MapsBridge.LogInfo(f\"Otsu's threshold value: {thresh_value}\")\r\n\r\n        # Invert binary image if particles are dark on light background\r\n        # This assumes particles are lighter than background. If particles are dark, this step might need adjustment.\r\n        # A common approach is to check histogram or assume based on typical EM images.\r\n        # For now, we assume lighter particles on darker background after thresholding.\r\n        # If your particles are dark, you might need `binary_img = ~binary_img` or similar.\r\n        \r\n        # Use morphological operations to clean up the binary image\r\n        # Opening removes small noise, closing fills small holes in particles\r\n        binary_img = morphology.remove_small_objects(binary_img, min_size=64, connectivity=2)\r\n        binary_img = morphology.remove_small_holes(binary_img, area_threshold=64)\r\n        \r\n        # Ensure particles are white (foreground) and background is black\r\n        # If Otsu's resulted in dark particles, invert it.\r\n        if np.mean(binary_img) > 0.5: # If majority of pixels are white, it means particles are dark.\r\n            binary_img = ~binary_img.astype(bool)\r\n\r\n        # Label connected regions (particles)\r\n        labeled_img, num_labels = measure.label(binary_img, connectivity=2, background=0, return_num=True)\r\n        \r\n        particle_count = num_labels - 1 if num_labels > 0 and np.mean(binary_img) < 0.5 else num_labels # Subtract 1 if background was counted as a label\r\n\r\n        MapsBridge.LogInfo(f\"Detected {particle_count} particles.\")\r\n\r\n        # Create a color image to draw on\r\n        color_img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)\r\n\r\n        # Draw bounding boxes and labels on the image\r\n        # Get stage coordinates if processing a tile\r\n        stage_coords_offset = (0, 0)\r\n        if tile_info and source_tile_set:\r\n            try:\r\n                stage_coords_offset = (tile_info.StagePosition.X, tile_info.StagePosition.Y)\r\n            except AttributeError:\r\n                MapsBridge.LogWarning(\"Could not retrieve StagePosition for tile. Annotations will be in pixel coordinates.\")\r\n        \r\n        for region in measure.regionprops(labeled_img):\r\n            # Draw bounding box\r\n            minr, minc, maxr, maxc = region.bbox\r\n            cv2.rectangle(color_img, (minc, minr), (maxc, maxr), (0, 255, 0), 2) # Green bounding box\r\n\r\n            # Add count label\r\n            label_text = f\"{region.label}\"\r\n            cv2.putText(color_img, label_text, (minc, minr - 5), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 1, cv2.LINE_AA) # Blue label\r\n\r\n            # Create annotation for each particle (optional, can be very many)\r\n            # If you want to annotate each particle, uncomment the following lines.\r\n            # Be aware that this can create a large number of annotations.\r\n            # particle_center_pixel = region.centroid\r\n            # pixel_x, pixel_y = int(particle_center_pixel[1]), int(particle_center_pixel[0])\r\n            #\r\n            # if tile_info and source_tile_set:\r\n            #     try:\r\n            #         stage_x, stage_y, _ = MapsBridge.TilePixelToStage(\r\n            #             pixel_x, pixel_y,\r\n            #             tile_info.Column, tile_info.Row, source_tile_set\r\n            #         )\r\n            #         MapsBridge.CreateAnnotation(\r\n            #             f\"Particle {region.label}\",\r\n            #             stagePosition=(stage_x, stage_y, 0),\r\n            #             targetLayerGroupName=\"Detected Particles\"\r\n            #         )\r\n            #     except Exception as e:\r\n            #         MapsBridge.LogWarning(f\"Failed to convert pixel to stage coordinates for particle {region.label}: {e}\")\r\n            # else: # If processing an Image Layer (stitched image)\r\n            #     # For image layers, we don't have tile info. We can create annotations relative to the image origin.\r\n            #     # If the image layer itself has stage position information, we could use that.\r\n            #     # For simplicity, we'll just log the pixel coordinates and skip annotation creation here.\r\n            #     MapsBridge.LogWarning(f\"Skipping annotation for particle {region.label} due to missing stage information for image layer.\")\r\n\r\n\r\n        # Overlay total count on the image\r\n        count_text = f\"Total Particles: {particle_count}\"\r\n        cv2.putText(color_img, count_text, (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 2, cv2.LINE_AA) # Red text for total count\r\n\r\n        # Save the processed image to a temporary folder\r\n        output_folder = MapsBridge.GetTempOutputFolder(\"ParticleDetection_Output\")\r\n        if tile_info: # If processing a tile\r\n            output_filename = f\"processed_tile_{tile_info.Column}_{tile_info.Row}.tif\"\r\n        else: # If processing a single image layer\r\n            output_filename = \"processed_image_layer.png\"\r\n        \r\n        output_path = os.path.join(output_folder, output_filename)\r\n        \r\n        # Ensure the directory exists\r\n        os.makedirs(output_folder, exist_ok=True)\r\n\r\n        # Save the result\r\n        success = cv2.imwrite(output_path, color_img)\r\n        if not success:\r\n            MapsBridge.LogError(f\"Failed to save processed image to: {output_path}\")\r\n            return None, 0\r\n\r\n        MapsBridge.LogInfo(f\"Saved processed image to: {output_path}\")\r\n        return output_path, particle_count\r\n\r\n    except Exception as e:\r\n        MapsBridge.LogError(f\"Error processing image {image_path}: {e}\")\r\n        return None, 0\r\n\r\ndef main():\r\n    try:\r\n        request = MapsBridge.FromStdIn()\r\n\r\n        if isinstance(request, MapsBridge.ScriptTileSetRequest):\r\n            MapsBridge.LogInfo(\"Processing as Tile Set.\")\r\n            source_tile_set = request.SourceTileSet\r\n            \r\n            # Create an output tile set if it doesn't exist\r\n            output_tile_set_info = MapsBridge.GetOrCreateOutputTileSet(\r\n                \"Particle Count Results\",\r\n                targetLayerGroupName=\"Outputs\"\r\n            )\r\n            output_tile_set_guid = output_tile_set_info.TileSet.Guid\r\n\r\n            # Create a channel for the processed tiles\r\n            channel_name = \"Particle Count\"\r\n            channel_color = (0, 255, 0) # Green\r\n            is_additive = False # Typically additive is for intensity overlays, non-additive for distinct layers\r\n            MapsBridge.CreateChannel(\r\n                channel_name,\r\n                channel_color,\r\n                is_additive,\r\n                output_tile_set_guid\r\n            )\r\n\r\n            total_particles_across_all_tiles = 0\r\n\r\n            # Iterate through each tile requested for processing\r\n            for tile, tile_info, input_path in MapsBridge.IterTilesToProcessWithPath(request, \"0\"):\r\n                MapsBridge.LogInfo(f\"Processing tile [{tile.Column}, {tile.Row}] from {os.path.basename(input_path)}\")\r\n                \r\n                processed_image_path, particle_count = process_image(input_path, tile_info, source_tile_set)\r\n                \r\n                if processed_image_path:\r\n                    total_particles_across_all_tiles += particle_count\r\n                    # Send the processed tile output\r\n                    MapsBridge.SendSingleTileOutput(\r\n                        tile_info.Row,\r\n                        tile_info.Column,\r\n                        channel_name, # Target channel name\r\n                        processed_image_path,\r\n                        keepFile=True, # Keep the temp file for debugging if needed\r\n                        targetTileSetGuid=output_tile_set_guid\r\n                    )\r\n            \r\n            MapsBridge.LogInfo(f\"Finished processing Tile Set. Total particles across all tiles: {total_particles_across_all_tiles}\")\r\n            # Optionally, append a summary note to the output tile set\r\n            MapsBridge.AppendNotes(\r\n                f\"Particle detection script completed.\\nTotal particles detected across all processed tiles: {total_particles_across_all_tiles}\\n\",\r\n                targetLayerGuid=output_tile_set_guid\r\n            )\r\n\r\n        elif isinstance(request, MapsBridge.ScriptImageLayerRequest):\r\n            MapsBridge.LogInfo(\"Processing as Image Layer/Stitched Image.\")\r\n            source_layer = request.SourceImageLayer\r\n            \r\n            # Get the path to the prepared image\r\n            # ðŸš¨ CRITICAL: Use STRING key \"0\" not integer 0\r\n            input_path = MapsBridge.GetPreparedImagePath(request, \"0\")\r\n            \r\n            if not input_path:\r\n                MapsBridge.LogError(\"Could not get prepared image path for channel '0'.\")\r\n                return\r\n\r\n            MapsBridge.LogInfo(f\"Processing image layer '{source_layer.Name}' from: {input_path}\")\r\n            \r\n            processed_image_path, particle_count = process_image(input_path)\r\n            \r\n            if processed_image_path:\r\n                # Create a new image layer with the results\r\n                MapsBridge.CreateImageLayer(\r\n                    f\"Particle Count: {source_layer.Name} ({particle_count} particles)\",\r\n                    processed_image_path,\r\n                    targetLayerGroupName=\"Outputs\",\r\n                    keepFile=True # Keep the temp file\r\n                )\r\n                MapsBridge.LogInfo(f\"Finished processing Image Layer '{source_layer.Name}'. Detected {particle_count} particles.\")\r\n                \r\n                # Optionally, append a note to the created image layer\r\n                # Note: MapsBridge.AppendNotes might not directly support ImageLayers as targets.\r\n                # We can log the info here for now. If specific layer annotation is needed,\r\n                # further API exploration for ImageLayer specific notes might be required.\r\n                # For now, the count is part of the layer name.\r\n\r\n        else:\r\n            MapsBridge.LogError(\"Unknown request type received.\")\r\n\r\n        MapsBridge.LogInfo(\"Script execution completed successfully.\")\r\n\r\n    except Exception as e:\r\n        MapsBridge.LogError(f\"An unhandled error occurred: {e}\")\r\n        # Re-raise to ensure MapsBridge catches the unhandled exception for logging\r\n        raise\r\n\r\nif __name__ == \"__main__\":\r\n    main()",
  "code_hash": "b11f708816b303b2",
  "user_prompt": null,
  "ai_model": null,
  "image_filename": "image.jpg",
  "error_message": "Script exited with code 2. Error: [ERROR] An unhandled error occurred: module 'MapsBridge' has no attribute 'FromStdIn'\nUser code error: module 'MapsBridge' has no attribute 'FromStdIn'\n[DEBUG] Full traceback:\nTraceback (most recent c",
  "error_type": "AttributeError",
  "stderr": "[ERROR] An unhandled error occurred: module 'MapsBridge' has no attribute 'FromStdIn'\nUser code error: module 'MapsBridge' has no attribute 'FromStdIn'\n[DEBUG] Full traceback:\nTraceback (most recent call last):\n  File \"/work/job_runner.py\", line 150, in main\n    exec(compile(src, str(code_path), \"exec\"), user_globals, user_globals)\n  File \"/code/main.py\", line 236, in <module>\n    main()\n  File \"/code/main.py\", line 142, in main\n    request = MapsBridge.FromStdIn()\n              ^^^^^^^^^^^^^^^^^^^^\nAttributeError: module 'MapsBridge' has no attribute 'FromStdIn'\n",
  "stdout": "============================================================\n[DEBUG] job_runner.py starting...\n[DEBUG] Python version: 3.11.14 (main, Dec  8 2025, 23:39:47) [GCC 14.2.0]\n[DEBUG] Working directory: /work\n[DEBUG] PYTHONPATH: /work\n============================================================\n[DEBUG] Checking /output directory...\n[DEBUG] /output exists\n[DEBUG] Contents of /output BEFORE script execution:\n[DEBUG]   - .matplotlib (is_file=False)\n[DEBUG] Contents of /input:\n[DEBUG]   - image.jpg (is_file=True)\n[DEBUG] Importing skimage and matplotlib...\n[DEBUG] Imports complete\n[DEBUG] Checking MapsBridge availability...\n[DEBUG] MapsBridge imported successfully from: /work/MapsBridge.py\n[DEBUG] main() starting...\n[DEBUG] Found code file: /code/main.py\n[DEBUG] Code to execute (11732 chars):\n----------------------------------------\n[DEBUG]   1: # Last Code Update - 11:58:27\n[DEBUG]   2: import os\n[DEBUG]   3: import MapsBridge\n[DEBUG]   4: import cv2\n[DEBUG]   5: import numpy as np\n[DEBUG]   6: from skimage import filters, measure, morphology\n[DEBUG]   7: from PIL import Image # Used for converting OpenCV images to PIL if needed for some MapsBridge outputs, or for general image handling.\n[DEBUG]   8: \n[DEBUG]   9: def process_image(image_path, tile_info=None, source_tile_set=None):\n[DEBUG]  10:     \"\"\"\n[DEBUG]  11:     Processes a single image to detect and count particles.\n[DEBUG]  12: \n[DEBUG]  13:     Args:\n[DEBUG]  14:         image_path (str): Path to the input image.\n[DEBUG]  15:         tile_info (MapsBridge.TileInfo, optional): Information about the tile being processed.\n[DEBUG]  16:                                                   Used for logging and output for Tile Sets.\n[DEBUG]  17:         source_tile_set (MapsBridge.SourceTileSet, optional): The source tile set object.\n[DEBUG]  18:                                                              Used for logging and output for Tile Sets.\n[DEBUG]  19: \n[DEBUG]  20:     Returns:\n[DEBUG] ... (216 more lines)\n----------------------------------------\n[DEBUG] Executing user code...\n[DEBUG] __name__ set to: __main__\n",
  "return_code": 2,
  "output_files": null,
  "execution_time_seconds": null,
  "previous_attempt_id": null,
  "fixed_by": null,
  "error_category": "attribute_error",
  "tags": [
    "lib:MapsBridge",
    "lib:numpy",
    "lib:PIL",
    "lib:skimage",
    "lib:cv2",
    "request_type:tileset",
    "request_type:imagelayer",
    "output:tile",
    "output:imagelayer",
    "output:channel",
    "error:input_parsing"
  ]
}