{
  "log_id": "c100e7fd-2a73-450a-816a-37e8f6e9611f",
  "session_id": "c100e7fd-2a73-450a-816a-37e8f6e9611f",
  "timestamp": "2025-12-21T09:31:09.647106",
  "status": "success",
  "code": "# Last Code Update - 09:30:51\r\nimport os\r\nimport MapsBridge\r\nimport cv2\r\nimport numpy as np\r\nfrom skimage import filters, measure, morphology\r\n\r\ndef detect_and_count_particles(image_path, threshold_value=50, min_area=10):\r\n    \"\"\"\r\n    Detects and counts particles in an image using thresholding and connected components.\r\n\r\n    Args:\r\n        image_path (str): The path to the input image.\r\n        threshold_value (int): The intensity threshold for particle detection.\r\n        min_area (int): The minimum area of a detected object to be considered a particle.\r\n\r\n    Returns:\r\n        tuple: A tuple containing:\r\n            - int: The total count of detected particles.\r\n            - np.ndarray: The image with detected particles highlighted.\r\n            - list: A list of dictionaries, each containing 'label', 'area', 'centroid' for each detected particle.\r\n    \"\"\"\r\n    try:\r\n        img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)\r\n        if img is None:\r\n            MapsBridge.LogError(f\"Error: Could not read image at {image_path}\")\r\n            return 0, None, []\r\n\r\n        # Apply Gaussian blur to reduce noise\r\n        blurred_img = cv2.GaussianBlur(img, (5, 5), 0)\r\n\r\n        # Apply Otsu's thresholding to get a binary image\r\n        # Or use a fixed threshold if Otsu is not suitable for your images\r\n        # thresh_val, binary_img = cv2.threshold(blurred_img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)\r\n        \r\n        # Using a fixed threshold as provided or a value to be set by the user\r\n        _, binary_img = cv2.threshold(blurred_img, threshold_value, 255, cv2.THRESH_BINARY)\r\n\r\n        # Invert the image if particles are dark on a light background\r\n        # You might need to adjust this based on your specific EM images\r\n        if np.mean(img) > threshold_value: # Heuristic: if image is generally lighter than threshold, invert\r\n             binary_img = cv2.bitwise_not(binary_img)\r\n\r\n        # Remove small noise using morphological opening\r\n        selem = morphology.disk(2) # Structuring element for morphological operations\r\n        binary_img = morphology.remove_small_objects(binary_img, min_size=min_area)\r\n        binary_img = morphology.opening(binary_img, selem)\r\n\r\n        # Label connected components (particles)\r\n        labeled_image, num_labels = measure.label(binary_img, connectivity=2, return_num=True)\r\n\r\n        # Measure properties of detected objects\r\n        regions = measure.regionprops(labeled_image)\r\n\r\n        particle_count = 0\r\n        detected_particles_info = []\r\n        output_img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR) # Convert to BGR for coloring\r\n\r\n        for region in regions:\r\n            if region.area >= min_area:\r\n                particle_count += 1\r\n                # Draw centroid and bounding box on the image\r\n                center_y, center_x = region.centroid\r\n                detected_particles_info.append({\r\n                    'label': region.label,\r\n                    'area': region.area,\r\n                    'centroid': (center_x, center_y)\r\n                })\r\n                \r\n                # Draw centroid\r\n                cv2.circle(output_img, (int(center_x), int(center_y)), 5, (0, 255, 0), -1) # Green centroid\r\n                \r\n                # Draw bounding box\r\n                minr, minc, maxr, maxc = region.bbox\r\n                cv2.rectangle(output_img, (minc, minr), (maxc, maxr), (255, 0, 0), 2) # Blue bounding box\r\n\r\n        MapsBridge.LogInfo(f\"Detected {particle_count} particles.\")\r\n        return particle_count, output_img, detected_particles_info\r\n\r\n    except Exception as e:\r\n        MapsBridge.LogError(f\"An error occurred during particle detection: {e}\")\r\n        return 0, None, []\r\n\r\ndef main():\r\n    # 1. Read tile set request\r\n    request = MapsBridge.ScriptTileSetRequest.FromStdIn()\r\n    sourceTileSet = request.SourceTileSet\r\n\r\n    # Parse script parameters (if any)\r\n    script_params = MapsBridge.ParseScriptParameters(request.ScriptParameters)\r\n    threshold_param = int(script_params.get(\"threshold_value\", 50)) # Default to 50 if not provided\r\n    min_area_param = int(script_params.get(\"min_area\", 10)) # Default to 10 if not provided\r\n\r\n    MapsBridge.LogInfo(f\"Processing {len(request.TilesToProcess)} tiles.\")\r\n    MapsBridge.LogInfo(f\"Using threshold value: {threshold_param}, min area: {min_area_param}\")\r\n\r\n    # Create an output tile set for results\r\n    # Use GetOrCreateOutputTileSet to ensure it's created if it doesn't exist\r\n    outputTileSetInfo = MapsBridge.GetOrCreateOutputTileSet(\r\n        f\"Particle Count: {sourceTileSet.Name}\",\r\n        targetLayerGroupName=\"Particle Analysis Results\"\r\n    )\r\n    outputTileSetGuid = outputTileSetInfo.TileSet.Guid\r\n\r\n    # Create output channels for the particle count image and the count itself\r\n    # The count will be logged, but we can also send it as metadata or in a separate output if needed.\r\n    # For now, we will log the count and send the image.\r\n    MapsBridge.CreateChannel(\r\n        \"Particle Detection\",\r\n        channelColor=(255, 0, 0), # Red color for the detection channel\r\n        isAdditive=True,\r\n        targetTileSetGuid=outputTileSetGuid,\r\n    )\r\n    \r\n    total_particles_across_all_tiles = 0\r\n\r\n    # Iterate through tiles requested by MAPS\r\n    for tile, tileInfo, input_path in MapsBridge.IterTilesToProcessWithPath(request, \"0\"):\r\n        MapsBridge.LogInfo(f\"Processing tile [{tile.Column}, {tile.Row}] from {os.path.basename(input_path)}\")\r\n\r\n        # Detect and count particles in the current tile\r\n        particle_count, result_img, detected_particles = detect_and_count_particles(\r\n            input_path, \r\n            threshold_value=threshold_param, \r\n            min_area=min_area_param\r\n        )\r\n        \r\n        total_particles_across_all_tiles += particle_count\r\n\r\n        if result_img is not None:\r\n            # Save the processed image to a temporary file\r\n            temp_output_folder = MapsBridge.GetTempOutputFolder(\"particle_detection_outputs\")\r\n            output_filename = f\"tile_{tile.Column}_{tile.Row}_detected.tif\"\r\n            output_path = os.path.join(temp_output_folder, output_filename)\r\n\r\n            try:\r\n                cv2.imwrite(output_path, result_img)\r\n\r\n                # Send the single tile output to the \"Particle Detection\" channel\r\n                MapsBridge.SendSingleTileOutput(\r\n                    tileRow=tileInfo.Row,\r\n                    tileColumn=tileInfo.Column,\r\n                    targetChannelName=\"Particle Detection\",\r\n                    imageFilePath=output_path,\r\n                    keepFile=True, # Keep the temporary file after sending\r\n                    targetTileSetGuid=outputTileSetGuid,\r\n                )\r\n                MapsBridge.LogInfo(f\"Sent detection image for tile [{tile.Column}, {tile.Row}]\")\r\n\r\n            except Exception as e:\r\n                MapsBridge.LogError(f\"Error saving or sending output for tile [{tile.Column}, {tile.Row}]: {e}\")\r\n        else:\r\n            MapsBridge.LogWarning(f\"No valid detection image generated for tile [{tile.Column}, {tile.Row}]\")\r\n\r\n    # Log the total count across all tiles\r\n    MapsBridge.LogInfo(f\"--- FINAL RESULT ---\")\r\n    MapsBridge.LogInfo(f\"Total particles detected across all tiles: {total_particles_across_all_tiles}\")\r\n    \r\n    # Optional: Append the total count as a note to the output tile set\r\n    MapsBridge.AppendNotes(\r\n        f\"Total particles detected across all tiles: {total_particles_across_all_tiles}\\n\",\r\n        targetTileSetGuid=outputTileSetGuid\r\n    )\r\n\r\n    MapsBridge.LogInfo(\"Particle detection and counting complete!\")\r\n\r\nif __name__ == \"__main__\":\r\n    main()",
  "code_hash": "e08a4c7b656608e1",
  "user_prompt": null,
  "ai_model": null,
  "image_filename": "image.tif",
  "error_message": null,
  "error_type": null,
  "stderr": null,
  "stdout": "============================================================\n[DEBUG] job_runner.py starting...\n[DEBUG] Python version: 3.11.14 (main, Dec  8 2025, 23:39:47) [GCC 14.2.0]\n[DEBUG] Working directory: /work\n[DEBUG] PYTHONPATH: /work\n============================================================\n[DEBUG] Checking /output directory...\n[DEBUG] /output exists\n[DEBUG] Contents of /output BEFORE script execution:\n[DEBUG]   - .matplotlib (is_file=False)\n[DEBUG] Contents of /input:\n[DEBUG]   - image.png (is_file=True)\n[DEBUG]   - image.tif (is_file=True)\n[DEBUG] Importing skimage and matplotlib...\n[DEBUG] Imports complete\n[DEBUG] Checking MapsBridge availability...\n[DEBUG] MapsBridge imported successfully from: /work/MapsBridge.py\n[DEBUG] main() starting...\n[DEBUG] Found code file: /code/main.py\n[DEBUG] Code to execute (7506 chars):\n----------------------------------------\n[DEBUG]   1: # Last Code Update - 09:30:51\n[DEBUG]   2: import os\n[DEBUG]   3: import MapsBridge\n[DEBUG]   4: import cv2\n[DEBUG]   5: import numpy as np\n[DEBUG]   6: from skimage import filters, measure, morphology\n[DEBUG]   7: \n[DEBUG]   8: def detect_and_count_particles(image_path, threshold_value=50, min_area=10):\n[DEBUG]   9:     \"\"\"\n[DEBUG]  10:     Detects and counts particles in an image using thresholding and connected components.\n[DEBUG]  11: \n[DEBUG]  12:     Args:\n[DEBUG]  13:         image_path (str): The path to the input image.\n[DEBUG]  14:         threshold_value (int): The intensity threshold for particle detection.\n[DEBUG]  15:         min_area (int): The minimum area of a detected object to be considered a particle.\n[DEBUG]  16: \n[DEBUG]  17:     Returns:\n[DEBUG]  18:         tuple: A tuple containing:\n[DEBUG]  19:             - int: The total count of detected particles.\n[DEBUG]  20:             - np.ndarray: The image with detected particles highlighted.\n[DEBUG] ... (148 more lines)\n----------------------------------------\n[DEBUG] Executing user code...\n[DEBUG] __name__ set to: __main__\n[MapsBridge DEBUG] ScriptTileSetRequest.FromStdIn() called\n[MapsBridge DEBUG] Input directory: /input, exists: True\n[MapsBridge DEBUG] Total image files found: 2\n[MapsBridge DEBUG] Extracted image metadata: 4096x3536, format=Gray8\n[MapsBridge DEBUG] Created ScriptTileSetRequest with 1 tiles\n[INFO] Processing 1 tiles.\n[INFO] Using threshold value: 50, min area: 10\n[INFO] Created output tile set: Particle Count: LocalTestTileSet (Guid: {BA37114B-42BD-4388-A4E0-042B80B639BE})\n[INFO] Created channel: Particle Detection with color (255, 0, 0)\n[INFO] Processing tile [1, 1] from image.png\n[INFO] Detected 84 particles.\n[MapsBridge DEBUG] SendSingleTileOutput() called:\n[MapsBridge DEBUG]   tileRow=1, tileColumn=1\n[MapsBridge DEBUG]   targetChannelName='Particle Detection'\n[MapsBridge DEBUG]   imageFilePath='/tmp/particle_detection_outputs/tile_1_1_detected.tif'\n[INFO] Output saved: Particle_Detection_tile_1_1_detected.tif (Channel: Particle Detection, Tile: [1, 1])\n[INFO] Sent detection image for tile [1, 1]\n[INFO] --- FINAL RESULT ---\n[INFO] Total particles detected across all tiles: 84\n[NOTE] Total particles detected across all tiles: 84\n[INFO] Particle detection and counting complete!\n[DEBUG] User code execution completed successfully\n[DEBUG] Contents of /output AFTER script execution:\n[DEBUG]   - .matplotlib/ (directory)\n[DEBUG]   - Particle_Detection_tile_1_1_detected.tif (12635136 bytes)\n[DEBUG] job_runner.py finished\n",
  "return_code": null,
  "output_files": [
    "Particle_Detection_tile_1_1_detected.tif"
  ],
  "execution_time_seconds": 10.17543077468872,
  "previous_attempt_id": null,
  "fixed_by": null,
  "error_category": null,
  "tags": [
    "lib:MapsBridge",
    "lib:numpy",
    "lib:skimage",
    "lib:cv2",
    "request_type:tileset",
    "output:tile",
    "output:channel"
  ]
}